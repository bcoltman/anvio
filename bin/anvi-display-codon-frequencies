#!/usr/bin/env python
# -*- coding: utf-8
"""Get codon or amino acid frequency statistics from genomes, genes, and functions."""

import os
import sys
import argparse

import anvio
import anvio.terminal as terminal
import anvio.constants as constants
import anvio.codonusage as codonusage
import anvio.filesnpaths as filesnpaths

from anvio.dbinfo import DBInfo
from anvio.argparse import ArgumentParser
from anvio.interactive import AdHocRunGenerator
from anvio.errors import ConfigError, FilesNPathsError
from anvio.utils import get_TAB_delimited_file_as_dictionary

import anvio.interactive as interactive
from anvio.bottleroutes import BottleApplication


__copyright__ = "Copyleft 2015-2024, The Anvi'o Project (http://anvio.org/)"
__credits__ = []
__license__ = "GPL 3.0"
__version__ = anvio.__version__
__authors__ = ['meren', 'semiller10']
__requires__ = ['contigs-db',
                'profile-db',
                'collection',
                'bin']
__provides__ = ['interactive', 'svg']
__description__ = ("Display codon frequency statistics across genes in a given")


run = terminal.Run()


def main(args):
    """Prepare arguments to get codon frequencies."""
    # Store the coding dictionary in `args`
    args.codon_to_amino_acid = codonusage.get_custom_encodings(args.encodings_txt)

    if args.include_amino_acids and args.exclude_amino_acids:
        raise ConfigError(
            "Either `--include-amino-acids` or `--exclude-amino-acids` should be given, not both.")

    # Amino acids to exclude are the complement of amino acids to include.
    if args.include_amino_acids:
        args.exclude_amino_acids = []
        for amino_acid in constants.amino_acids:
            if amino_acid in args.include_amino_acids:
                continue
            else:
                args.exclude_amino_acids.append(amino_acid)

    args.pansequence_min_amino_acids = [int(args.pansequence_min_amino_acids[0]),
                                        float(args.pansequence_min_amino_acids[1])]

    single_genome_codon_usage = codonusage.SingleGenomeCodonUsage(args, run=run)
    frequency_df = single_genome_codon_usage.get_frequencies(
        return_amino_acids=args.return_amino_acids,
        gene_caller_ids=args.gene_caller_ids,
        relative=args.relative,
        synonymous=args.synonymous,
        sum_genes=args.sum,
        average_genes=args.average,
        gene_min_codons=args.gene_min_codons,
        min_codon_filter=args.min_codon_filter,
        drop_amino_acids=args.exclude_amino_acids,
        sequence_min_amino_acids=args.sequence_min_amino_acids,
        pansequence_min_amino_acids=args.pansequence_min_amino_acids,
        label_amino_acids=args.header_amino_acids,
        infinity_to_zero=args.infinity_to_zero)

    # determine the output directory to write the frequency view data
    output_dir = filesnpaths.get_temp_directory_path()

    output_file = os.path.join(output_dir, 'condon-frequency-data.txt')

    # Write output tables.
    frequency_df.to_csv(output_file, sep='\t')

    import anvio.dbops as dbops
    import anvio.tables as t
    import anvio.utils as utils


    data_dict = get_TAB_delimited_file_as_dictionary(output_file, key_prefix='g_')

    # get functions
    contigs_db = dbops.ContigsDatabase(args.contigs_db)
    functions_dict = contigs_db.db.get_table_as_dict(t.gene_function_calls_table_name)
    functions_dict = utils.get_filtered_dict(functions_dict, 'source', set(['KOfam']))
    contigs_db.disconnect()

    gene_caller_id_to_kofam = {}
    for entry in list(functions_dict.values()):
        if entry['accession']:
            gene_caller_id_to_kofam[entry['gene_callers_id']] = entry['accession'].split('!!!')[0]

    # setup additional items data. remember, at this point every gene caller id has a prefix `g_`
    # to avoid downstream issues, so one of the ways to ensure we keep track of gene calls is to
    # have an additional data layer with the actual anvi'o gene caller ID information
    additional_items_data = {}
    ribosomal_proteins = ["K02946", "K02906", "K02926", "K02930", "K02892", "K02886", "K02965", "K02890", "K02982", "K02878", "K02904", "K02961", "K02874", "K02895", "K02987", "K02931", "K02954", "K02994", "K02933", "K02912", "K02885", "K02881", "K02988", "K02907", "K02876", "K02919", "K02952", "K02948", "K02986", "K02883", "K02879", "K02871", "K02996", "K02992", "K02950", "K07590", "K02936", "K02979", "K02896", "K02935", "K02869", "K02864", "K02863", "K02867", "K02967", "K02956", "K02916", "K02887", "K02914", "K02939", "K02963", "K02990", "K02888", "K02899", "K02902", "K02913", "K02911", "K02909", "K02897", "K02959", "K02884", "K02968", "K02945", "K02970"]
    for gene_call_with_prefix in data_dict:
        gene_call = int(gene_call_with_prefix.lstrip('g_'))

        if gene_call in gene_caller_id_to_kofam:
            if gene_caller_id_to_kofam[gene_call] in ribosomal_proteins:
                d = {'gene_call': gene_call, 'function_category': 'Ribosomal Proteins'}
            else:
                d = {'gene_call': gene_call, 'function_category': None}
        else:
            d = {'gene_call': gene_call, 'function_category': None}

        additional_items_data[gene_call_with_prefix] = d

    # learn about our codons
    codons_in_data_dict = next(iter(data_dict.values())).keys()
    codons_to_display = [codon for codon in constants.coding_codons if codon in codons_in_data_dict]

    # setup additional layer data
    additional_layers_data = {}

    # start with codon to AA
    for codon in codons_to_display:
        additional_layers_data[codon] = {'amino_acid': constants.codon_to_AA[codon]}

    g = AdHocRunGenerator(output_dir, data_dict, None, codons_to_display, linkage='ward')
    g.delete_output_directory_if_exists = True
    g.generate()
    g.add_items_additional_data(additional_items_data, ['gene_call', 'function_category'])
    g.add_layers_additional_data(additional_layers_data, ['amino_acid'])
    g.add_state('default', state_path=os.path.join(os.path.dirname(anvio.__file__), 'data/mini-states/display-codons.json'))

    J = lambda x: os.path.join(output_dir, x)
    args_for_interactive = argparse.Namespace(profile_db=J('profile.db'),
                                              manual_mode=True,
                                              fasta_file=None,
                                              view_data=J('view.txt'),
                                              tree=J('tree.txt'),
                                              ip_address=args.ip_address,
                                              title=f"Codon Composition for {DBInfo(args.contigs_db).project_name}",
                                              port_number=args.port_number,
                                              browser_path=args.browser_path,
                                              read_only=args.read_only,
                                              server_only=args.server_only,
                                              password_protected=args.password_protected,
                                              user_server_shutdown=args.user_server_shutdown)
    # go interactive
    d = interactive.Interactive(args_for_interactive)
    args.port_number = utils.get_port_num(args.port_number, args.ip_address, run=run)
    app = BottleApplication(d)
    app.run_application(args.ip_address, args.port_number)


if __name__ == '__main__':
    parser = ArgumentParser(description=__description__)

    groupA = parser.add_argument_group('GENOME', "Show us where to find the genome to Display codons "
        "across genes in a single genome. It could also be a bin stored in a collection.")
    groupA.add_argument(*anvio.A('contigs-db'), **anvio.K('contigs-db', {'required': False}))
    groupA.add_argument(*anvio.A('profile-db'), **anvio.K('profile-db', {'required': False}))
    groupA.add_argument(*anvio.A('collection-name'), **anvio.K('collection-name'))
    groupA.add_argument(*anvio.A('bin-id'), **anvio.K('bin-id'))
    groupA.add_argument(
        '--gene-caller-ids', type=int, nargs='+', help="Select genes by ID, space-separated.")

    groupC = parser.add_argument_group(
        'OUTPUT FILES',
        "This program writes codon or amino acid frequency tables. When functions rather than "
        "genes are analyzed, one of two possible files can be produced: a table of frequencies per "
        "gene or per function, using `--gene-table-output` or `--function-table-output`, "
        "respectively. The per-function table can be derived from the per-gene table by summing "
        "genes with the same function annotation, which are found in columns 2-4.")
    groupC.add_argument(*anvio.A('output-file'), **anvio.K('output-file'))
    groupC.add_argument(
        '--gene-table-output',
        help="A tab-delimited file of genes x codons or amino acids. The index columns before "
             "frequency data contain genome names (optional, if multiple genomes are considered) "
             "and gene callers IDs.")
    groupC.add_argument(
        '--header-amino-acids', default=False, action='store_true',
        help="Include the amino acid for each codon in the column header of codon output, i.e., "
             "LysAAA instead of AAA.")
    groupC.add_argument(
        '--infinity-to-zero', default=False, action='store_true',
        help="Replace NA (empty) values in output with 0.0. NA occurs with `--synonymous` when all "
             "codons for an amino acid are absent in a gene or function, resulting in 0/0, "
             "reported as NA. Use with caution, for NA and 0.0 mean different things and this will "
             "skew downstream analyses of synonymous relative frequencies, such as codon usage "
             "bias.")


    groupD = parser.add_argument_group('FREQUENCY STATISTICS', "How should codon frequencies be computed.")
    groupD.add_argument(
        '--relative', default=False, action='store_true',
        help="Return relative frequencies across codons or amino acids in each gene or function.")
    groupD.add_argument(
        '--synonymous', default=False, action='store_true',
        help="Return synonymous (per-amino acid) frequencies among the codons encoding each amino "
             "acid in each gene or function.")
    groupD.add_argument(
        '--return-amino-acids', default=False, action='store_true',
        help="Return frequencies of codons encoding the same amino acid.")
    groupD.add_argument(
        '--encodings-txt',
        help="Changes to the standard genetic code can be provided in this tab-delimited file of "
             "two columns. Each entry in the first column is a codon and each entry in the second "
             "column is the three-letter code for the decoded amino acid. For example, to recode "
             "the stop codon, TGA, as Trp, 'TGA' would be placed in the first column and 'Trp' in "
             "the same row of the second. Stop/termination codons are abbreviated \"STP\". This "
             "option affects per-amino acid and synonymous codon output (when using "
             "`--return-amino-acids` or `--synonymous`).")
    groupD.add_argument(
        '--sum', default=False, action='store_true',
        help="Sum frequencies across genes, returning a single row for each genome. When functions "
             "or function sources are selected, genes are subsetted to those annotated with the "
             "requested functions or annotated by the requested sources.")
    groupD.add_argument(
        '--average', default=False, action='store_true',
        help="Average frequencies across genes in the genome, returning a single row for each "
             "genome. When functions or function sources are selected, genes are subsetted to "
             "those annotated with the requested functions or annotated by the requested sources.")

    groupF = parser.add_argument_group(
        'FILTER GENES, FUNCTIONS, CODONS',
        "Genes/functions can be filtered by the number of codons they contain, e.g., ignore genes "
        "shorter than 300 codons. Codons can be selected a priori, e.g., ignore Ala codons, or "
        "rarer codons can be excluded, e.g., ignore amino acids that are decoded by ≤3 codons in "
        "≥90%% of genes. Filters can improve the statistical utility of codon relative frequency "
        "data.")
    groupF.add_argument(
        '--gene-min-codons', type=int, default=0,
        help="Set the minimum number of codons required in a gene. When functions are returned "
             "rather than genes, this filter is applied to genes before grouping them as "
             "functions.")
    groupF.add_argument(
        '--function-min-codons', type=int, default=0,
        help="Set the minimum number of codons required in a function. Genes with fewer than "
             "`--gene-min-codons` are first removed, and then functional groups of the remaining "
             "genes with fewer than `--function-min-codons` are removed. This filter only applies "
             "when returning functions.")
    groupF.add_argument(
        '--exclude-amino-acids', nargs='+',
        help="Remove codons that decode the given amino acids (use three-letter codes, e.g., Ala, "
             "and STP for stop codons). If `--synonymous`, this argument defaults to \"STP Met "
             "Trp\".")
    groupF.add_argument(
        '--include-amino-acids', nargs='+',
        help="This is the complement of `--exclude-amino-acids`. Only codons for the given amino "
             "acids are analyzed and reported.")
    groupF.add_argument(
        '--sequence-min-amino-acids', type=int, default=0,
        help="Do not report codons for amino acids (and STP) that are less numerous than the given "
             "argument. For example, if the argument is 5, and a gene or function query has 4 "
             "codons encoding Asn, 2 AAT and 2 AAC, then a row for this gene in the output table "
             "will have missing values in Asn columns. This filter occurs at the end of the "
             "analysis before writing results and so does not affect prior calculations.")
    groupF.add_argument(
        '--pansequence-min-amino-acids', nargs=2, default=[0, 1.0],
        help="The first value of the argument is a positive integer representing a minimum number "
             "of codons encoding an amino acid -- 'min_amino_acids' -- and the second is a number "
             "between 0 and 1 representing a fraction of genes -- 'min_gene_fraction'. Remove "
             "codons for amino acids (and STP) that are less numerous than 'min_amino_acids' in a "
             "'min_gene_fraction' of genes. For example, if 'min_amino_acids' is 5 and "
             "'min_gene_fraction' is 0.9, then if there are fewer than 5 codons for an amino "
             "acid/STP in ≥90%% of genes, then the columns for these codons are dropped.")
    groupF.add_argument(
        '--min-codon-filter', choices=['length', 'remaining', 'both'], default='both',
        help="This argument arises from the ambiguity of filters that remove genes and functions "
             "by number of codons (`--gene-min-codons` and `--function-min-codons`) in relation to "
             "filters that drop codons (`--exclude/include-amino-acids` and "
             "`--pansequence-min-amino-acids`). Genes (and functions) can be filtered by "
             "their full length, e.g., genes shorter than 300 codons are ignored. They can also be "
             "filtered by the number of codons remaining after dropping codons. The codon length "
             "filter followed by dropping codons can result in genes and functions with fewer "
             "codons than the original codon threshold -- thus the option of both \"length\" and "
             "\"remaining\" filters to ensure that total codon frequencies in the output always "
             "meet the minimum codon threshold. \"both\" is needed as an option in addition to "
             "\"remaining\" so dynamic codon filtering by `--pansequence-min-amino-acids` operates "
             "on genes that passed the first length filter.")


    groupX = parser.add_argument_group('SERVER CONFIGURATION', "For power users.")
    groupX.add_argument(*anvio.A('ip-address'), **anvio.K('ip-address'))
    groupX.add_argument(*anvio.A('port-number'), **anvio.K('port-number'))
    groupX.add_argument(*anvio.A('browser-path'), **anvio.K('browser-path'))
    groupX.add_argument(*anvio.A('read-only'), **anvio.K('read-only'))
    groupX.add_argument(*anvio.A('server-only'), **anvio.K('server-only'))
    groupX.add_argument(*anvio.A('password-protected'), **anvio.K('password-protected'))
    groupX.add_argument(*anvio.A('user-server-shutdown'), **anvio.K('user-server-shutdown'))



    args = parser.get_args(parser)

    try:
        main(args)
    except ConfigError as e:
        print(e)
        sys.exit(-1)
    except FilesNPathsError as e:
        print(e)
        sys.exit(-2)
